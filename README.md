# Proyectos hechos para Clientes

<details>
	<summary>Proyecto 1</summary>

# Funeraría La Unión www.funerarialaunion.cl (Chile)

 **Tecnologías utilizadas**
<p align="center">
  <img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black" alt="JavaScript" />
  <img src="https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=css3&logoColor=white" alt="CSS3" />
  <img src="https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=html5&logoColor=white" alt="HTML5" />
  <img src="https://img.shields.io/badge/Cloudflare-F38020?style=for-the-badge&logo=cloudflare&logoColor=white" alt="Cloudflare" />
</p>

## Imágenes con Hipervínculos

[![Screenshot from 2026-02-18 15-58-17](https://github.com/user-attachments/assets/d46bae01-c24b-4754-81eb-7339f919aa83)](https://www.funerarialaunion.cl)
[![Screenshot from 2026-02-18 15-58-33](https://github.com/user-attachments/assets/423f102c-0699-41ad-9782-23e850eff771)](https://www.funerarialaunion.cl/ubicacion)

</details>

<details>
	<summary>Proyecto 2</summary>

# Gestor de Productos/Stock/Ventas en Excel asociado a una Webapp

 **Tecnologías utilizadas**
<p align="center">
  <img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black" alt="JavaScript" />
  <img src="https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=css3&logoColor=white" alt="CSS3" />
  <img src="https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=html5&logoColor=white" alt="HTML5" />
  <img src="https://img.shields.io/badge/Google%20Apps%20Script-4285F4?style=for-the-badge&logo=googleapps&logoColor=white" alt="Google Apps Script" />
  <img src="https://img.shields.io/badge/Excel-217346?style=for-the-badge&logo=microsoftexcel&logoColor=white" alt="Excel" />
  <img src="https://img.shields.io/badge/Cloudflare-F38020?style=for-the-badge&logo=cloudflare&logoColor=white" alt="Cloudflare" />
</p>

## Imágenes con Hipervínculos

## Gestor en Excel (Solo lectura)

### Registrar y modificar Productos

[![Screenshot from 2025-07-26 11-18-06](https://github.com/user-attachments/assets/ea27de39-a572-4777-94eb-ba19aa68c6a2)](https://docs.google.com/spreadsheets/d/1bAWnvUEpwE99F7vQJWXQyTF9YEDViv7gL2M8NR58hO0/edit?usp=sharing)

### Registrar Ventas

[![Screenshot from 2025-07-26 10-48-13](https://github.com/user-attachments/assets/2e81672a-444b-4c71-96c8-126dba39081b)](https://docs.google.com/spreadsheets/d/1bAWnvUEpwE99F7vQJWXQyTF9YEDViv7gL2M8NR58hO0/edit?usp=sharing)

### Registrar Stock

[![Screenshot from 2025-07-26 11-24-31](https://github.com/user-attachments/assets/97228c34-f37e-485d-aa56-0e3ccc59879e)](https://docs.google.com/spreadsheets/d/1bAWnvUEpwE99F7vQJWXQyTF9YEDViv7gL2M8NR58hO0/edit?usp=sharing)


## Gestor desde una Webapp que actualiza el Excel

[![Screenshot from 2025-07-26 11-48-13](https://github.com/user-attachments/assets/b48c6fbd-f797-4811-88e4-7afd1052f7f2)](https://appforexcel.luzardo-thomas.workers.dev/)
[![Screenshot from 2025-07-26 11-48-14](https://github.com/user-attachments/assets/5303d0d0-72a6-4a0b-9c84-5c87a9e2eca8)](https://appforexcel.luzardo-thomas.workers.dev/)
[![Screenshot from 2025-07-26 11-48-15](https://github.com/user-attachments/assets/b1d7b96a-699f-4e7e-9927-e3c5cf96d283)](https://appforexcel.luzardo-thomas.workers.dev/)
[![Screenshot from 2025-07-26 11-48-16](https://github.com/user-attachments/assets/e007878d-5206-4399-924c-c015b82e389e)](https://appforexcel.luzardo-thomas.workers.dev/)

</details>

# Proyecto OpenSource de TV + Mobile

<details>
	<summary>Proyecto</summary>
	
**Tecnologías utilizadas**
	
<p align="center">
  <img src="https://img.shields.io/badge/Kotlin-7F52FF?style=for-the-badge&logo=kotlin&logoColor=white" alt="Kotlin" />
  <img src="https://img.shields.io/badge/VLC-FF8800?style=for-the-badge&logo=videolan&logoColor=white" alt="VLC" />
  <img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black" alt="JavaScript" />
  <img src="https://img.shields.io/badge/Cloudflare-F38020?style=for-the-badge&logo=cloudflare&logoColor=white" alt="Cloudflare" />
</p>

## Objetivos de la APP

WatchOffline está diseñada para combinar la potencia de VLC con una experiencia de usuario inspirada en una interfaz de una plataforma de Streaming, facilitando la reproducción de contenido multimedia de forma simple, consistente e intuitiva.

El objetivo principal de la aplicación es permitir el consumo de contenido sin depender de una conexión a internet, una vez que los datos necesarios han sido cargados. El contenido puede importarse desde:

- Pendrives
- Discos duros externos
- Almacenamiento interno del dispositivo

Este contenido queda disponible para su reproducción completamente offline, exceptuando la carga inicial de metadatos, que se obtiene desde una API.

Para mejorar la experiencia de uso, WatchOffline ofrece funcionalidades como:

- Saltear intros de series
- Armado de playlists aleatorias
- Navegación optimizada tanto para Android TV como para dispositivos móviles

Además, WatchOffline gestiona de forma global y persistente los tracks de audio y subtítulos, replicando un comportamiento típico de plataformas de Streaming.  
Por ejemplo, si el usuario selecciona audio en inglés y subtítulos en español, la aplicación aplicará automáticamente esa configuración a todo el contenido compatible, siempre que el archivo multimedia lo permita, sin necesidad de realizar ajustes manuales en cada reproducción.

Como alternativa al almacenamiento local, la aplicación incluye soporte para servidores SMB, permitiendo conectarse a uno o múltiples servidores para importar y reproducir contenido de manera flexible.  
A diferencia del contenido local, el uso de SMB requiere conexión a red, pero mantiene siempre el control local del usuario sobre sus archivos, sin depender de servicios externos.



## TV
<img width="1043" height="589" alt="Screenshot from 2026-01-18 15-08-06" src="https://github.com/user-attachments/assets/8f89aff5-f702-4bc3-a245-65206f347235" />
<img width="1043" height="589" alt="Screenshot from 2026-01-18 15-08-15" src="https://github.com/user-attachments/assets/1804e5dc-cebb-4111-ab39-221233f7b29f" />
<img width="1043" height="589" alt="Screenshot from 2026-01-18 15-08-20" src="https://github.com/user-attachments/assets/c5faa8e5-30b1-42e0-ace2-e666323e941a" />
<img width="1043" height="589" alt="Screenshot from 2026-01-18 15-08-49" src="https://github.com/user-attachments/assets/5fed5702-f404-4a3d-a4f0-d83fd8720994" />
<img width="1043" height="589" alt="Screenshot from 2026-01-18 15-09-55" src="https://github.com/user-attachments/assets/89cefc64-bfd8-4875-8d6a-c6f996ff2c00" />

## Mobile
<img width="1059" height="478" alt="Screenshot from 2026-01-18 15-11-18" src="https://github.com/user-attachments/assets/09f2ba29-322a-4e79-8e31-407f6a381923" />
<img width="1059" height="478" alt="Screenshot from 2026-01-18 15-11-26" src="https://github.com/user-attachments/assets/9669d29c-5767-483d-8926-b366729a0cb4" />
<img width="1059" height="478" alt="Screenshot from 2026-01-18 15-11-37" src="https://github.com/user-attachments/assets/714850e8-21b9-482b-ae1b-a7b538639f20" />
<img width="1059" height="478" alt="Screenshot from 2026-01-18 15-12-42" src="https://github.com/user-attachments/assets/9ac36559-c975-4b78-a3c7-896bb8b9daea" />

## Funcionalidades

### Acciones principales
<img width="1013" height="243" alt="Screenshot from 2026-01-03 12-58-10" src="https://github.com/user-attachments/assets/b3af376d-aeca-4970-bde3-eefd84b6561d" />
<img width="1009" height="241" alt="Screenshot from 2026-01-03 13-20-52" src="https://github.com/user-attachments/assets/01fa70df-5741-4d95-b835-52dba302dff2" />
<img width="768" height="201" alt="Screenshot from 2026-01-03 13-21-45" src="https://github.com/user-attachments/assets/2fb4fa67-4d78-4971-a1f4-0f326054bfab" />
<img width="808" height="226" alt="Screenshot from 2026-01-03 12-59-01" src="https://github.com/user-attachments/assets/2c1e2102-7a2f-40c2-8b3a-d41b978d9ef3" />

### Armado de reproducción
<img width="1007" height="199" alt="Screenshot from 2026-01-03 12-59-10" src="https://github.com/user-attachments/assets/bdf08cfd-cc3b-4966-bc48-ada51ff8e35d" />
<img width="1018" height="231" alt="Screenshot from 2026-01-03 12-59-17" src="https://github.com/user-attachments/assets/56d4c718-5c4c-4810-9980-39a68716e9e3" />
<img width="1018" height="231" alt="Screenshot from 2026-01-03 12-59-23" src="https://github.com/user-attachments/assets/8126180c-d59f-4b2b-9fd2-3fd3ea084eca" />
<img width="905" height="237" alt="Screenshot from 2026-01-03 12-59-32" src="https://github.com/user-attachments/assets/707f559b-ce47-4f01-a4b6-be0ac7e3998f" />

### Acciones avanzadas
<img width="1007" height="235" alt="Screenshot from 2026-01-03 13-26-05" src="https://github.com/user-attachments/assets/6b92058c-bfce-43c9-84c6-d11cc3ef8bbe" />
<img width="992" height="318" alt="Screenshot from 2026-01-03 13-22-48" src="https://github.com/user-attachments/assets/4ea86edb-6a12-41e8-9e3a-d8bcab4ec5bf" />
<img width="783" height="226" alt="Screenshot from 2026-01-03 12-59-59" src="https://github.com/user-attachments/assets/9b0c4018-8e07-4d19-8d6f-66a0108ac998" />
<img width="630" height="232" alt="Screenshot from 2026-01-03 13-00-06" src="https://github.com/user-attachments/assets/882bc9c8-e23d-48fd-8ae3-19a9b8b327a8" />


</details>


# Proyectos de Desarrollo WEB

<details>
	<summary>Proyecto 1</summary>

# Plataforma para ver trailers de series y películas

 **Tecnologías utilizadas**
<p align="center">
  <img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black" alt="JavaScript" />
  <img src="https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=css3&logoColor=white" alt="CSS3" />
  <img src="https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=html5&logoColor=white" alt="HTML5" />
  <img src="https://img.shields.io/badge/TailwindCSS-38B2AC?style=for-the-badge&logo=tailwind-css&logoColor=white" alt="TailwindCSS" />
  <img src="https://img.shields.io/badge/MongoDB-47A248?style=for-the-badge&logo=mongodb&logoColor=white" alt="MongoDB" />
  <img src="https://img.shields.io/badge/Express.js-000000?style=for-the-badge&logo=express&logoColor=white" alt="ExpressJS" />
  <img src="https://img.shields.io/badge/React-20232A?style=for-the-badge&logo=react&logoColor=61DAFB" alt="React" />
  <img src="https://img.shields.io/badge/Node.js-43853D?style=for-the-badge&logo=node-dot-js&logoColor=white" alt="NodeJS" />
</p>

## Imágenes con Hipervínculos
	
[![Screenshot from 2024-10-16 11-18-06](https://github.com/user-attachments/assets/d5817225-a29f-4b68-8b7b-fa1c6382b680)](https://chillstream.onrender.com)
[![Screenshot from 2024-10-16 11-24-31](https://github.com/user-attachments/assets/812c8fdf-f494-493a-9473-ebb5d647eb1d)](https://chillstream.onrender.com/login)
[![Screenshot from 2024-10-16 10-48-13](https://github.com/user-attachments/assets/0e1d41fd-5fc9-4335-903c-d67b665f71e7)](https://chillstream.onrender.com)

</details>

# Scripts desarrollados en Bash

<details>
	<summary>Instalación</summary>
	
## Comando para instalar los Scripts
	
```bash
# Clonar el repositorio en la versión más actual
git clone --depth=1 https://github.com/luzardothomas/portfolio_luzardo_thomas.git
# Entrar al directorio donde se encuentra el instalador
cd portfolio_luzardo_thomas/linux_tools
# Ejecutar el instalador
bash installer.sh
```
## Opciones del Instalador
1. **Install:** Instala un script o todos a la vez.
2. **Uninstall:** Desinstala un script o todos a la vez.
3.  **Reinstall:** Reinstala todos los scripts a la vez.
</details>

	
<details>
	<summary>Testing</summary>
	
## Comando para ejecutar un lote de pruebas para cada Script

```bash
 # Entrar al directorio donde se encuentra el tester
 cd portfolio_luzardo_thomas/linux_tools/x_test_scripts/
 # Ejecutar el tester
 bash test_scripts.sh
```
## Opciones del Tester
1. **Test script:** Testea uno o todos los scripts a la vez.
2. **Regenerate test directories:** Elimina todos los directorios y recupera los test de los scripts copiandolos desde su directorio.
	
</details>

<details>
	<summary>Scripts</summary>

---

<details>
	<summary>Script 1: extract_directory_files</summary>

<details>
	<summary>Resumen</summary>
	
Extrae los archivos que se encuentran en los directorios, los almacena en un directorio y elimina los directorios vaciados.

</details>


<details>
	<summary>Sintaxis y parametros enviados</summary>
	
## Sintaxis

```
extract_directory_files ~/ruta comando_saltar nombre_directorio
```

## Parametros

* **Ruta (opcional):** La dirección que se mande tiene que incluir ~/* , dicho de otra forma /home/usuario/*. Si no se manda ninguna ruta entonces se utiliza la ruta del directorio actual en el que se encuentra.
* **Comando saltar (opcional):** Se utiliza para saltar la pregunta de seguridad que aparece luego de ejecutar el script.
* **Nombre directorio (obligatorio):** Es el nombre del directorio general donde se va a guardar el resultado de la extracción de archivos. No puede elegirse un nombre de directorio que ya exista dentro en la dirección en la que se ejecuta el Script.

| **⚠ Caracteres inválidos en el nombre del Directorio ⚠**  |
| ------------- |
| Nombre de Directorio vacío      | 
| Espacio      | 
| `/` Barra diagonal     |
|`\` Barra diagonal inversa|
|`:` Dos puntos|
|`*` Asterisco|
|`?` Signo de interrogación|
|`"` Comillas dobles|
|`<` Menor que|
|`>` Mayor que|
|`\|` Barra vertical|
    
</details>
	
<details>
	<summary>Funcionamiento</summary>

 1. Crea un directorio merge (nombre_directorio)
 2. Por orden ascendente va a recorrer los directorios que hay en la ruta mandada o en la que se encuentra
 3. Busca la ruta de todos los archivos con el comando "find"
 4. Mueve esos archivos al merge y luego borra el directorio que se recorrió
 5. El bucle se da en los pasos 2,3 y 4. El proceso finaliza cuando recorrió todos los directorios
	
</details>

<details>
	<summary>Ejemplo detallado de cómo funciona</summary>
	
#### Estado inicial

![image](https://github.com/user-attachments/assets/7a3f3066-1680-4705-a2c6-a5cf30a8ee95)

![foto1](https://github.com/user-attachments/assets/6005f385-4dc0-4e38-b596-aca107b8e133)

#### Estado final

![image](https://github.com/user-attachments/assets/280b4c1b-08be-4179-99f5-8774711c41f5)

</details>


<details>
	<summary>Formas de usarlo</summary>

```bash
extract_directory_files ~/ruta nombre_directorio 
# los archivos obtenidos en la ruta guardan en nombre_directorio
```
```bash
extract_directory_files nombre_directorio 
# sin ruta especificada significa directorio actual
```
```bash
extract_directory_files -sk nombre_directorio 
# sk significa saltar pregunta
```
</details>
	
</details>

---

<details>
	<summary>Script 2: rename_files</summary>

<details>
	<summary>Resumen</summary>

Renombra los archivos utilizando una plantilla.

</details>


<details>
	<summary>Sintaxis y parametros enviados</summary>
	
```
rename_files ~/ruta comando_saltar nombre_plantilla
```
* **Ruta (opcional):** La dirección que se mande tiene que incluir ~/* , dicho de otra forma /home/usuario/*. Si no se manda ninguna ruta entonces se utiliza la ruta del directorio actual en el que se encuentra.
* **Comando de saltar (opcional):** Se utiliza para saltar la pregunta que se da luego de ejecutar el script.
* **Nombre de la plantilla (obligatorio):** Es el nombre del directorio general (merge) en el que se va a guardar el resultado del renombramiento de los archivos. No se puede usar si ya existen archivos con esa plantilla.

| **⚠ Caracteres inválidos en el nombre del Directorio ⚠**  |
| ------------- |
| Nombre de Directorio vacío      | 
| Espacio      | 
| `/` Barra diagonal     |
|`\` Barra diagonal inversa|
|`:` Dos puntos|
|`*` Asterisco|
|`?` Signo de interrogación|
|`"` Comillas dobles|
|`<` Menor que|
|`>` Mayor que|
|`\|` Barra vertical|

</details>
	
<details>
	<summary>Funcionamiento</summary>


 1. Separa los archivos que va a recorrer en orden ascendente
 2. Inicializa un contador en 1
 3. Recorre los archivos en orden ascendente
 4. Obtiene la extensión del archivo
 5. El nombre nuevo del archivo va a tener como formato:
    * plantilla ; contador ; extensión
 6. Renombra el archivo con el nuevo nombre
 7. Le suma 1 al contador
 8. El bucle se da en los pasos 3,4,5, 6 y 7. El proceso finaliza cuando recorrió todos los archivos


</details>

<details>
	<summary>Ejemplo detallado de cómo funciona</summary>
	
#### Estado inicial

![image](https://github.com/user-attachments/assets/96feb98c-6b09-4a49-a590-1ac81f45f776)

![foto2](https://github.com/user-attachments/assets/ae71b943-2289-4122-8b51-0032925f9f36)

#### Estado final

![image](https://github.com/user-attachments/assets/dcafe4b7-7f55-4b23-8e55-97b3a28a0ed3)

</details>


<details>
	<summary>Formas de usarlo</summary>

```bash
rename_files ~/ruta nombre_plantilla 
# los archivos obtenidos en la ruta guardan en nombre_directorio
```
```bash
rename_files nombre_plantilla  
# sin ruta especificada significa directorio actual
```
```bash
rename_files -sk nombre_plantilla  
# sk significa saltar pregunta
```

</details>

	
</details>

---

<details>
	<summary>Script 3: smart_unzip</summary>

<details>
	<summary>Resumen</summary>

Extrae los archivos de cada archivo .zip, elimina el .zip original y almacena los archivos en un directorio.	

</details>


<details>
	<summary>Sintaxis y parametros enviados</summary>

```
smart_unzip ~/ruta comando_saltar nombre_directorio
```
* **Ruta (opcional):** La dirección que se mande tiene que incluir ~/* , dicho de otra forma /home/usuario/*. Si no se manda ninguna ruta entonces se utiliza la ruta del directorio actual en el que se encuentra.
* **Comando saltar (opcional):** Se utiliza para saltar la pregunta que se da luego de ejecutar el script.
* **Nombre directorio (obligatorio):** Directorio en el que se va a guardar el resultado de la extracción de archivos. No se puede crear si ya existe un directorio con el mismo nombre.

| **⚠ Caracteres inválidos en el nombre del Directorio ⚠**  |
| ------------- |
| Nombre de Directorio vacío      | 
| Espacio      | 
| `/` Barra diagonal     |
|`\` Barra diagonal inversa|
|`:` Dos puntos|
|`*` Asterisco|
|`?` Signo de interrogación|
|`"` Comillas dobles|
|`<` Menor que|
|`>` Mayor que|
|`\|` Barra vertical|	

</details>
	
<details>
	<summary>Funcionamiento</summary>


 1. Crea un directorio merge (nombre_directorio)
 2. Por orden ascendente va a recorrer los archivos .zip que hay en la ruta mandada o en la que se encuentra
 3. Extrae todos los archivos que se encuentran en el .zip en el merge
 4. Elimina el archivo .zip original
 5. El bucle se da en los pasos 2,3 y 4. El proceso finaliza cuando no hayan más archivos .zip

</details>

<details>
	<summary>Ejemplo detallado de cómo funciona</summary>

#### Estado inicial

![image](https://github.com/user-attachments/assets/85218118-008b-4034-80f9-2beb8b1d326b)

![foto3](https://github.com/user-attachments/assets/55a8145d-679a-4906-99a2-041f6cf036a3)

#### Estado final

![image](https://github.com/user-attachments/assets/3932a2f6-bb76-4c6f-b3ca-cba8e35b2cfb)
	
</details>

<details>
	<summary>Formas de usarlo</summary>

```bash
smart_unzip ~/ruta nombre_directorio 
# los archivos extraídos del .zip se guardan en el merge (nombre_directorio)
```
```bash
smart_unzip_files nombre_directorio 
# sin ruta especificada significa directorio actual
```
```bash
smart_unzip -sk nombre_directorio 
# sk significa saltar pregunta
```

</details>

</details>

---

<details>
	<summary>Script 4: smart_zip</summary>


<details>
	<summary>Resumen</summary>

Comprime cada directorio en un archivo .zip, elimina el directorio original y almacena todos los .zip en un directorio.
	
</details>


<details>
	<summary>Sintaxis y parametros enviados</summary>

```bash
smart_zip ~/ruta comando_saltar nombre_directorio
```
* **Ruta (opcional):** La dirección que se mande tiene que incluir ~/* , dicho de otra forma /home/usuario/*. Si no se manda ninguna ruta entonces se utiliza la ruta del directorio actual en el que se encuentra.
* **Comando saltar (opcional):** Se utiliza para saltar la pregunta que se da luego de ejecutar el script.
* **Nombre directorio (obligatorio):** Directorio en el que se va a guardar el resultado de la compresión de archivos. No se puede crear si ya existe un directorio con el mismo nombre.

| **⚠ Caracteres inválidos en el nombre del Directorio ⚠**  |
| ------------- |
| Nombre de Directorio vacío      | 
| Espacio      | 
| `/` Barra diagonal     |
|`\` Barra diagonal inversa|
|`:` Dos puntos|
|`*` Asterisco|
|`?` Signo de interrogación|
|`"` Comillas dobles|
|`<` Menor que|
|`>` Mayor que|
|`\|` Barra vertical|	

</details>
	
<details>
	<summary>Funcionamiento</summary>

1. Crea un directorio merge
2. Por orden ascendente va a recorrer los directorios que hay en la ruta mandada o en la que se encuentra
3. Comprime un archivo a formato .zip
4. Se mueve el archivo .zip al merge
5. Elimina el directorio original
6. El bucle se da en los pasos 2,3 y 4. El proceso finaliza una vez que no hay más directorios

</details>

<details>
	<summary>Ejemplo detallado de cómo funciona</summary>

#### Estado inicial

![image](https://github.com/user-attachments/assets/3b421764-b8dd-4737-a9b1-50d25d9d10a1)

![foto4](https://github.com/user-attachments/assets/ca637d7e-6d39-4727-b0ff-f5489a9467af)

#### Estado final

![image](https://github.com/user-attachments/assets/543de425-b38c-4844-acea-dfa02a61254d)
	
</details>


<details>
	<summary>Formas de usarlo</summary>

```bash
smart_zip ~/ruta nombre_directorio 
# los archivos obtenidos en la ruta guardan en nombre_directorio
```
```bash
smart_zip nombre_directorio 
# sin ruta especificada significa directorio actual
```
```bash
smart_zip -sk nombre_directorio 
# sk significa saltar pregunta
```

</details>
	
</details>

---

<details>
	<summary>Script 5: wrap_files</summary>


<details>
	<summary>Resumen</summary>

Crea un directorio para cada archivo, almacena ese archivo en el directorio creado con su mismo nombre, y almacena esos directorios en un directorio.
	
</details>


<details>
	<summary>Sintaxis y parametros enviados</summary>

```
wrap_files ~/ruta comando_saltar nombre_directorio
```
* **Ruta (opcional):** La dirección que se mande tiene que incluir ~/* , dicho de otra forma /home/usuario/*. Si no se manda ninguna ruta entonces se utiliza la ruta del directorio actual en el que se encuentra.
* **Comando saltar (opcional):** Se utiliza para saltar la pregunta que se da luego de ejecutar el script.
* **Nombre directorio (obligatorio):** Es el nombre del directorio general (merge) en el que se va a guardar el resultado de la creación de directorios para cada archivo. Los directorios se llaman igual que el archivo que contienen. No se puede crear si ya existe un directorio con el mismo nombre.

| **⚠ Caracteres inválidos en el nombre del Directorio ⚠**  |
| ------------- |
| Nombre de Directorio vacío      | 
| Espacio      | 
| `/` Barra diagonal     |
|`\` Barra diagonal inversa|
|`:` Dos puntos|
|`*` Asterisco|
|`?` Signo de interrogación|
|`"` Comillas dobles|
|`<` Menor que|
|`>` Mayor que|
|`\|` Barra vertical|	

</details>
	
<details>
	<summary>Funcionamiento</summary>

 1. Crea un directorio merge (nombre_directorio).
 2. Por orden ascendente va a recorrer los archivos que hay en la ruta mandada o en la que se encuentra
 3. Crea un directorio para el archivo
 4. Mueve el archivo a su correspondiente directorio
 5. Mueve el directorio del archivo al merge
 6. El bucle se da en los pasos 2,3, 4 y 5. El proceso finaliza una vez que no hay más archivos


</details>

<details>
	<summary>Ejemplo detallado de cómo funciona</summary>


#### Estado inicial

![image](https://github.com/user-attachments/assets/5416e060-4ff2-4092-a332-7882faa94844)

![foto5](https://github.com/user-attachments/assets/542b98a6-573d-4d57-93c9-719a9638a269)

#### Estado final

![image](https://github.com/user-attachments/assets/ee402a1a-8e60-40e0-a90f-ac96a9e8a608)

</details>


<details>
	<summary>Formas de usarlo</summary>

```bash
wrap_files ~/ruta nombre_directorio 
# los archivos obtenidos en la ruta guardan en nombre_directorio
```
```bash
wrap_files directory_name 
# sin ruta especificada significa directorio actual
```
```bash
wrap_files -sk directory_name 
# sk significa saltar pregunta
```

</details>

	
</details>

---

<details>
	<summary>Script 6: wrap_files_in_groups</summary>

<details>
	<summary>Resumen</summary>

Almacena un grupo o varios grupos de archivos en uno o varios directorios.
	
</details>


<details>
	<summary>Sintaxis y parametros enviados</summary>

```
wrap_files_in_groups ~/ruta comando_saltar nombre_grupo rango
```
* **Ruta (opcional):** La dirección que se mande debe incluir ~/* , dicho de otra forma /home/usuario/*. Si no se manda ninguna ruta entonces se utiliza la ruta del directorio actual si es que cumple la condición anterior.

* **Comando saltar (opcional):** Se utiliza para saltar la pregunta y elegir la opción 1 o 2.
* **Nombre grupo (opcional):** Si no se manda el nombre del grupo previamente se lo va a pedir después. Es un directorio o muchos que almacenan una cantidad de archivos acorde al rango establecido. No se puede crear si ya existe un directorio con el mismo nombre que el grupo.
* **Rango (obligatorio):** Formato a-b (ambos números) que sirve para indicar cuántos archivos se quiere seleccionar. Si se pone 1-10 el rango se calcula con la diferencia del extremo superior y el inferior sumándole uno (10-1+1), por lo que seleccionaría los 10 primeros archivos que se encuentren en el orden ascendente. No se aceptan rangos negativos.

| **⚠ Caracteres inválidos en el nombre del Directorio ⚠**  |
| ------------- |
| Nombre de Directorio vacío      | 
| Espacio      | 
| `/` Barra diagonal     |
|`\` Barra diagonal inversa|
|`:` Dos puntos|
|`*` Asterisco|
|`?` Signo de interrogación|
|`"` Comillas dobles|
|`<` Menor que|
|`>` Mayor que|
|`\|` Barra vertical|
	

</details>
	
<details>
	<summary>Funcionamiento</summary>

 1. Separa los archivos en orden ascendente
 2. Inicializa un contador en 0
 3. Selecciona un rango de archivos
 4. Le suma 1 al contador
 5. Crea el directorio para un grupo de archivos
 6. Se mueve el rango de archivos a su grupo correspondiente
 7. El bucle se da en los pasos 3,4,5 y 6. El proceso finaliza cuando ya no hay más rangos

</details>

<details>
	<summary>Ejemplo 1 detallado de cómo funciona</summary>

#### Estado inicial

![image](https://github.com/user-attachments/assets/6612f735-c02c-4735-b283-a065b633888e)

![foto6 1](https://github.com/user-attachments/assets/2bf19032-6538-4610-91b6-d9a61ab103c8)

#### Estado final

![image](https://github.com/user-attachments/assets/09ae6f9c-b13d-4f31-a343-c1b0122a1ba8)

	

</details>

<details>
	<summary>Ejemplo 2 detallado de cómo funciona</summary>


#### Estado inicial

![image](https://github.com/user-attachments/assets/57800075-9b0e-4af1-bec9-f62f5a598672)

![foto6 2](https://github.com/user-attachments/assets/91a6fe71-aa11-436a-b6e9-9744520f29b2)

#### Estado final

![image](https://github.com/user-attachments/assets/99efe177-77ef-4601-9c4f-264240a1c2de)

</details>


<details>
	<summary>Formas de usarlo</summary>

```bash
wrap_files_in_groups ~/ruta 1-10
# selecciona un grupo de 10 archivos y luego le toca al usuario decidir entre opcion 1 o 2
# opción 1 : nombre_plantilla | opción 2: nombre_grupo (como es solo un grupo da igual)
```
```bash
wrap_files_in_groups 1-10
# sin ruta especificada significa directorio actual
```
```bash
wrap_files_in_groups -sk1 1-2 3-6 7-10
# sk1 significa saltar pregunta y elegir opción 1
# la plantilla es solo una y la va a pedir por pantalla
# ejemplo: plantilla = nombre_ejemplo, son 3 grupos (1-2,3-6,7-10)
# nombre_ejemplo_1: 2 archivos, nombre_ejemplo_2: 4 archivos, nombre_ejemplo_3: 4 archivos
```
```bash
wrap_files_in_groups -sk1 nombre_grupo 1-2 3-6 7-10
# la plantilla es solo una y ya fue mandada previamente
# nombre_grupo_1: 2 archivos, nombre_grupo_2: 4 archivos, nombre_grupo_3: 4 archivos
```
```bash
wrap_files_in_groups -sk2 1-2 3-6 7-10
# sk2 significa saltar pregunta y elegir opción 2
# usar nombre_grupo como nombres especificos para grupos y se pide por pantalla
# ejemplo: son 3 grupos (1-2,3-6,7-10) por lo que habra que escribir tres nombre_grupo
# nombre_grupo_1 = grupoA, nombre_grupo_2 = grupoB, nombre_grupo_3 = grupoC
# grupoA_1: 2 archivos, grupoB_2: 4 archivos, grupoC_3: 4 archivos
```
```bash
wrap_files_in_groups -sk2 nombre_grupo_A nombre_grupo_B nombre_grupo_C 1-2 3-6 7-10
# se pe mandaron previamente cada uno de los nombres especificos para grupos
# cantidad de nombre_grupo = cantidad de grupos (cada rango es un grupo)
# nombre_grupo_A_1: 2 archivos, nombre_grupo_B_2: 4 archivos, nombre_grupo_C_3: 4 archivos
```

</details>


	
</details>

 

 
</details>







